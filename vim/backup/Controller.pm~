package WSB::Controller;
use strict;
use warnings;

use File::Fetch;
use File::Copy qw(copy);
use Params::Validate qw(:all);
use Archive::Extract;
use WSB;
use WSB::Software;
use WSB::Messages;
use WSB::Color;

use constant CON_CHECK_ENABLED	=> 1;
use constant CON_CHECK_INSTALL	=> 2;
use constant CON_CHECK_DEPS		=> 4;
use constant CON_CHECK_ALL		=> 7;

my $color = new WSB::Color();
my $msg   = new WSB::Messages();

$File::Fetch::BLACKLIST = [qw(lwp httplite netftp httptiny)];
$File::Fetch::WARN      = 0;

sub new {
	my $class = shift;
	my $self  = {};
	
	bless($self, $class);
	
	return $self;
}

sub status {
	my $self     = shift;
	my $software = new WSB::Software();
	my $header;
	
	### Write status table to file to be displayed via 'less' later
	open (STATUS, ">/tmp/wsb.status");
	
	$header = "S |";
	$header = $header . sprintf " %-25s |", "Software Name";
	$header = $header . sprintf " %-8s |", "Version";
	$header = $header . sprintf " %-37s", "Description";
	
	print STATUS $header, "\n";
	print STATUS "--+---------------------------+----------+--------------------------------------\n";
	
	close (STATUS);
	
	foreach($software->get_software_list()) {
		my $obj = $software->get_software_obj($_);
		$self->status_row($_, $obj);
	}
	
	system("/usr/bin/less", "-RF", "/tmp/wsb.status");
	unlink("/tmp/wsb.status");
}

sub status_row {
	my $self     = shift;
	my $name     = shift;
	my $obj      = shift;
	my $software = new WSB::Software();
	my $basedir  = WSB->get_wsb_dir('home');
	my $cols     = 0;
	my $row;
	
	if ($software->state($name, 'upgrade') && $software->state($name, 'installed')) {
		$row = 'U';
	} elsif ($software->state($name, 'installed')) {
		$row = 'I';
	} elsif ($obj->exists("archive")) {
		$row = ((-f "${basedir}/downloads/".$obj->archive) ? 'D' : ' ');
	} else {
		$row = ' ';
	}
	$row = $row . ' | ';

	if ($obj->exists('version')) {
		$cols = 23;
	} else {
		$row = $row . '  ';
		$cols = 21;
	}
	
	if ($software->state($name, 'enabled')) {
		$row = $row . '+ ';
		
		if ($software->state($name, 'dirty')) {
			$row = $row . $color->warn(sprintf("%-${cols}s", $name));
		} else {
			$row = $row . $color->success(sprintf("%-${cols}s", $name));
		}
	} else {
		$row = $row . '- ' . $color->error(sprintf("%-${cols}s", $name));
	}
	
	$row = $row . ' | ';
	
	if ($obj->exists('version')) {
		if ($software->state($name, 'upgrade') && $software->state($name, 'installed')) {
			$row = $row . $color->warn(sprintf("%-8s", $obj->version));
		} else {
			$row = $row . sprintf("%-8s", $obj->version);
		}
	} else {
		$row = $row . sprintf("%-8s", "");
	}
	
	$row = $row . ' | ';
	
	if (length($obj->name) > 37) {
		$row = $row . substr($obj->name, 0, 35).'->';
	} else {
		$row = $row . $obj->name;
	}
	
	open(STATUS, ">>/tmp/wsb.status");
	print STATUS $row, "\n";
	close(STATUS);
	
	### If this is software, re-run status_row for every plugin
	if ($obj->exists('version')) {
		foreach ($obj->keys('plugin')) {
			my $plugin = $obj->obj('plugin')->obj($_);
			$self->status_row($_, $plugin);
		}
	}
}

sub download {
	my $self = shift;
	my @p    = validate_pos(@_, 1);
	my $software = new WSB::Software();
	my $downdir  = WSB->get_wsb_dir('downloads');
	my $srcdir   = WSB->get_wsb_dir('src');
	my $obj  = $software->get_software_obj($p[0]);
	
	return unless defined($obj);
	return 1 unless $self->can_continue($p[0], CON_CHECK_ENABLED);
	
	$msg->header(msg => 'Downloading '.$obj->name, type => 'info');
	$msg->action($obj->archive);
	
	### Download
	if (-f "${downdir}/".$obj->archive) {
		$msg->action_result(0);
		print $color->comment("-- Archive has already been downloaded."), "\n";
	} else {
		my $dl = File::Fetch->new( uri => $obj->url );
		my $where;
		eval {
			$where = $dl->fetch( to => $downdir ) || return;
		};
		
		if ($@) {
			$msg->action_result(1);
			print $color->error("-- FATAL: Problem initiating download.\n");
			
			return;
		} elsif ($? || not defined $where) {
			$msg->action_result(1);
			print $color->error("-- Archive download failed.\n");
			
			return;
		} else {
			$msg->action_result(0);
		}
		
		if ($where ne "${downdir}/".$obj->archive) {
			my $target = "${downdir}/".$obj->archive;
			`mv "$where" "$target"`;
		}
	}
	
	$msg->action("Unpacking ".$obj->archive);
	
	### Unpack
	if (-d "${srcdir}/".$obj->srcdir) {
		$msg->action_result(0);
		print $color->comment("-- Archive has already been unpacked."), "\n";
	} elsif ($software->state($p[0], 'enabled')) {
		my $ae = Archive::Extract->new(archive => "${downdir}/".$obj->archive);
		$ae->extract(to => "${srcdir}");
		if ($?) {
			$msg->action_result(1);
			
			return;
		} else {
			$msg->action_result(0);
		}
	}
	
	return 1;
}

sub build {
	my $self = shift;
	my @p    = validate_pos(@_, 1);
	my $software = new WSB::Software();
	my $basedir = WSB->get_wsb_dir('home');
	my $srcdir = WSB->get_wsb_dir('src');
	my $depdir = WSB->get_wsb_dir('support')."/dep";
	my $color = new WSB::Color();
	my $msg = new WSB::Messages();
	my $obj  = $software->get_software_obj($p[0]);
	my $cmd;
	
	return unless defined($obj);
	return 1 unless $self->can_continue($p[0], CON_CHECK_ENABLED | CON_CHECK_DEPS);
	
	### Make sure software is downloaded and unpacked.
	return unless $self->download($p[0]);
	
	### Setup environment variables
	$self->_env($obj);

	$msg->header(msg => "Building ".$obj->name, type => 'info');
	
	### Setup environment variables
	$self->_env($obj);
	
	### Run pre-script
	$cmd = "${basedir}/support/".$p[0].".pre";
	if (-f $cmd) {
		system("$cmd");
		if ($?) {
			print $color->error("PRE-SCRIPT: ".$cmd." failed for ".$obj->name."\n");
			
			return;
		}
	}
	
	### Check for dependencies available from repositories
	chdir("${depdir}");
	if (-f "${p[0]}.dep") {
		open(DEP, "<${p[0]}.dep");
		while (<DEP>) {
			chomp($_);
    
			system("rpm", "-q", "--quiet", "$_");
			if ($?) {
				$msg->action("Installing package: $_");
				system("yum", "-y", "-q", "install", "$_");
				if ($?) {
					$msg->action_result(1);
					print $color->error("Failed to install package $_.");
					
					return;
				} else {
					$msg->action_result(0);
				}
			}
		}
		close(DEP);
	}
	
	chdir("${srcdir}/".$obj->srcdir);
	### Process 'clean', 'configure', 'make', and 'test'
	if ($obj->exists("build")) {
		my $build = $obj->obj("build");
		
		### CLEAN
		if ($build->value("clean")) {
			$cmd = $build->clean;
        
			system("$cmd"); ### Don't care if this fails
		}
		
		### CONFIGURE
		if ($build->value("configure")) {
			$cmd = $build->configure;
        
			### Add plugin configure options
			foreach ($obj->keys("plugin")) {
				if ($software->state($_, 'enabled')) {
					my $plugin = $obj->obj("plugin")->obj($_);
					
					if ($plugin->value("configure")) {
						$cmd = "$cmd ".$plugin->configure;
					}
				}
			}
			
			system("$cmd");
			if ($?) {
				$color->error("BUILD: configure failed for ".$obj->name."\n");
				
				return;
			}
		}
		
		### MAKE
		if ($build->value("make")) {
			$cmd = $build->make;
			
			system("$cmd");
			if ($?) {
				$color->error("BUILD: make failed for ".$obj->name."\n");
				
				return;
			}
		}
		
		### TEST
		if ($build->value("test")) {
			$cmd = $build->test;
			
			system("$cmd");
			if ($?) {
				$color->error("BUILD: test failed for ".$obj->name."\n");
				
				return;
			}
		}
	}
	
	return 1;
}

sub install {
	my $self = shift;
	my @p = validate_pos(@_, 1);
	my $software = new WSB::Software();
	my $basedir = WSB->get_wsb_dir('home');
	my $color = new WSB::Color();
	my $msg = new WSB::Messages();
	my $obj = $software->get_software_obj($p[0]);
	my $cmd;
	
	return 1 unless $self->can_continue($p[0], CON_CHECK_ALL);
	
	### Make sure software is compiled
	return unless $self->build($p[0]);
	
	$msg->header(msg => "Installing ".$obj->name, type => 'info');
	
	### Setup environment variables
	$self->_env($obj);
	
    ### Refresh ldconfig
    system("/sbin/ldconfig");
    
	### Process 'install'
	if ($obj->exists("build")) {
		my $build = $obj->obj("build");
		
		### INSTALL
		if ($build->value("install")) {
			$cmd = $build->install;
			
			system("$cmd");
			if ($?) {
				$color->error("BUILD: install failed for ".$obj->name."\n");
				
				return;
			}
		}
	}
	
	### EXEC plugins
	foreach ($obj->keys("plugin")) {
		if ($software->state($_, 'enabled')) {
			my $plugin = $obj->obj("plugin")->obj($_);
			
			if ($plugin->exists("exec")) {
				$cmd = "${basedir}/support".$plugin->exec;
			}
			
			system("$cmd");
			if ($?) {
				$color->error("PLUGIN: exec failed for $_\n");
				
				return;
			}
		}
	}
	
	### Run post-script
	$cmd = "${basedir}/support/$p[0].post";
	if (-f $cmd) {
		system("$cmd");
		if ($?) {
			$color->error("POST-SCRIPT: ".$cmd."failed for ".$obj->name."\n");
			
			return;
		}
	}
	
	### Install Upstart service(s)
	if (-f "${basedir}/support/init/$p[0].conf") {
		copy("${basedir}/support/init/$p[0].conf", "/etc/init/$p[0].conf");
		system("initctl", "start", "$p[0]");
	}
	
	### Install start/stop script
	if (-f "${basedir}/support/init.d/$p[0]") {
		copy("${basedir}/support/init.d/$p[0]", "/etc/init.d/");
        system("chmod", "755", "/etc/init.d/$p[0]");
        system("/sbin/chkconfig", "--level", "2345", "$p[0]", "on");
        system("/sbin/service", "$p[0]", "start");
	}
	
    ### Install monit config
    if (-f "${basedir}/support/monit.d/$p[0].conf") {
        copy("${basedir}/support/monit.d/$p[0].conf", "/etc/monit.d/");
        system("/sbin/reload", "monit");
    }
    
    ### Install logrotate config
    if (-f "${basedir}/support/logrotate.d/$p[0]") {
        copy("${basedir}/support/logrotate.d/$p[0]", "/etc/logrotate.d/");
    }
    
	### Set plugins installed state
	foreach ($obj->keys("plugin")) {
		if ($software->state($_, 'enabled')) {
			$software->installed($_, 1);
		} else {
			$software->installed($_, 0);
		}
	}
	
	### Set software installed state 
	$software->installed($p[0], 1);
	
	return 1;
}

sub can_continue {
	my $self = shift;
	my @p    = validate_pos(@_, 1, 1);
	my $software = new WSB::Software();
	my $color = new WSB::Color();
	my $obj  = $software->get_software_obj($p[0]);
	
	unless (defined $obj) { return; }
	
	### Check if software is enabled
	if ($p[1] & CON_CHECK_ENABLED) {
		unless ($software->state($p[0], 'enabled')) {
			print $color->warn($obj->name." is disabled."), "\n";
			
			return;
		}
	}
	
	### Check if software is installed
	if ($p[1] & CON_CHECK_INSTALL) {
		if (not $software->state($p[0], 'dirty')) {
			if ($software->state($p[0], 'installed')) {
				print $color->warn($obj->name." is already installed."), "\n";
				
				return;
			}
		}
	}
	
	### Make sure dependencies are installed
	if ($p[1] & CON_CHECK_DEPS) {
		my @deps = $software->get_dependencies($p[0]);
		
		foreach (@deps) {
			unless ($_ eq 'last' || $_ eq 'first') {
				if (not $software->state($_, 'installed')) {
					print $color->error("Dependency $_ is not installed."), "\n";
					
					return;
				}
			}
		}
	}
	
	return 1;
}

sub _env {
	my $self = shift;
	my $obj  = shift;
	my $basedir = WSB->get_wsb_dir('conf');
	
	$ENV{APP_DIR} = WSB->get_wsb_dir('home');
	$ENV{SRCDIR}  = WSB->get_wsb_dir('src')."/".$obj->srcdir;
	$ENV{ARCHIVE} = WSB->get_wsb_dir('downloads')."/".$obj->archive;
	if ($obj->exists('install_path')) {
		$ENV{INSTALL_PATH} = $obj->install_path;
	} else {
		$ENV{INSTALL_PATH} = "/usr/local";
	}
	
	open(ENV, "<${basedir}/BUILD_ENV");
	while (<ENV>) {
		chomp;
		if ($_ =~ /^#/) {
			next;
		}
		my ($name, $value) = split('=');
		$ENV{$name} = $value;
	}
	close(ENV);
	
	return 1;
}
1;